return {}
-- local open_stream_popup = (function()
--   local buf = nil
--   local win = nil
--   local content_lines = {}
--
--   local function ensure_popup()
--     if not vim.api.nvim_buf_is_valid(buf) or not vim.api.nvim_win_is_valid(win) then
--       buf = vim.api.nvim_create_buf(false, true)
--       if not vim.api.nvim_buf_is_valid(buf) then return end
--
--       vim.bo[buf].buftype = "nofile"
--       vim.bo[buf].bufhidden = "delete"
--       vim.bo[buf].filetype = "markdown"
--
--       win = vim.api.nvim_open_win(buf, false, {
--         relative = "cursor",
--         row = 2,
--         col = 0,
--         width = math.min(vim.o.columns * 0.8, 100),
--         height = math.min(#content_lines, 20),
--         style = "minimal",
--         border = "rounded",
--       })
--
--       vim.wo[win].winblend = 10
--
--       -- Close with <Esc> or q
--       vim.keymap.set("n", "<esc>", function()
--         if vim.api.nvim_win_is_valid(win) then vim.api.nvim_win_close(win, true) end
--       end, { buffer = buf, nowait = true, silent = true })
--
--       vim.keymap.set("n", "q", function()
--         if vim.api.nvim_win_is_valid(win) then vim.api.nvim_win_close(win, true) end
--       end, { buffer = buf, nowait = true, silent = true })
--
--       vim.on_key(function()
--         if vim.api.nvim_win_is_valid(win) then vim.api.nvim_win_close(win, true) end
--       end, buf)
--     end
--   end
--
--   return {
--     append = function(delta)
--       if delta and delta ~= "" then
--         local lines = vim.fn.split(delta, "\n", { plain = true })
--         vim.list_extend(content_lines, lines)
--         ensure_popup()
--         vim.api.nvim_buf_set_lines(buf, 0, -1, false, content_lines)
--       end
--     end,
--     close = function()
--       if vim.api.nvim_win_is_valid(win) then vim.api.nvim_win_close(win, true) end
--       buf = nil
--       win = nil
--       content_lines = {}
--     end
--   }
-- end)()
--
-- vim.api.nvim_create_autocmd("User", {
--   pattern = "OpencodeEvent:*",
--   callback = function(args)
--     local event = args.data.event
--     local session_id = args.data.session_id -- if present
--
--     -- Streaming: catch assistant text deltas
--     if event.type == "message.part.updated" and event.properties and event.properties.delta then
--       open_stream_popup.append(event.properties.delta) 
--       return
--     end
--
--     -- Finalization: optional cleanup on idle
--     if event.type == "session.idle" then
--       vim.notify("opencode finished streaming")
--       -- popup stays open until user closes it; you can call open_stream_popup.close() here if you want
--     end
--   end,
-- })
--
-- return {
--   "NickvanDyke/opencode.nvim",
--   dependencies = {
--     { "folke/snacks.nvim", opts = { input = {}, picker = {}, terminal = {} } },
--   },
--   config = function()
--     vim.g.opencode_opts = {
--     }
--     vim.o.autoread = true
--
--     vim.keymap.set({ "n", "x" }, "<leader>h", function()
--       require("opencode").ask("@this: ", { submit = true })
--     end, { desc = "Ask opencodeâ€¦" })
--   end,
-- }
--
